# setting up local variables of whole program
alloc 1
mkvec 1
setlv
# setting up global variables
alloc 2
mkvec 2
setgv
# setting up params vector
alloc 1
mkvec 1
setpv
# body of program
# Start of LocalExpression(localvars=[('x', SelfEvaluatingExpression(id=1))], body=SequenceExpression(seq=[LocalExpression(localvars=[('x', LambdaExpression(params=['y'], body=ITEExpression(condition=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='<', e2=SelfEvaluatingExpression(id=1)), ifbody=SelfEvaluatingExpression(id=0), elsebody=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='+', e2=CallExpression(procname=VariableExpression(name='x'), params=[BinaryOperatorExpression(e1=VariableExpression(name='y'), op='-', e2=SelfEvaluatingExpression(id=1))])))))], body=BinaryOperatorExpression(e1=CallExpression(procname=VariableExpression(name='x'), params=[SelfEvaluatingExpression(id=2)]), op='+', e2=VariableExpression(name='x')))]))
loadc 1
mkbasic
pushlocalvec
# scope of x: local
rewrite 0
pop 1
# local body
# Start of LocalExpression(localvars=[('x', LambdaExpression(params=['y'], body=ITEExpression(condition=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='<', e2=SelfEvaluatingExpression(id=1)), ifbody=SelfEvaluatingExpression(id=0), elsebody=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='+', e2=CallExpression(procname=VariableExpression(name='x'), params=[BinaryOperatorExpression(e1=VariableExpression(name='y'), op='-', e2=SelfEvaluatingExpression(id=1))])))))], body=BinaryOperatorExpression(e1=CallExpression(procname=VariableExpression(name='x'), params=[SelfEvaluatingExpression(id=2)]), op='+', e2=VariableExpression(name='x')))
# save old local values
pushlocalvec
pushaddr 0
### fill 0, x
pushlocalvec
pushaddr 0
mkvec 1
mkfunval lambda_0
jump end_lambda_0
lambda_0:
ite_0:
pushparamvec
pushaddr 0
getbasic
loadc 1
le
jumpz else_0
then_0:
loadc 0
mkbasic
jump endite_0
else_0:
pushparamvec
pushaddr 0
getbasic
mark back_from_call_0
pushparamvec
pushaddr 0
getbasic
loadc 1
sub
mkbasic
pushparamvec
storeaddr 0
pop 1
pushglobalvec
pushaddr 0
apply
back_from_call_0:
getbasic
add
mkbasic
endite_0:
popenv
end_lambda_0:
pushlocalvec
# scope of x: local
rewrite 0
pop 1
# local body
mark back_from_call_1
loadc 2
mkbasic
pushparamvec
storeaddr 0
pop 1
pushlocalvec
pushaddr 0
apply
back_from_call_1:
getbasic
pushlocalvec
pushaddr 0
getbasic
add
mkbasic
# restore old local values
swap
pushlocalvec
storeaddr 0
pop 1
# End of LocalExpression(localvars=[('x', LambdaExpression(params=['y'], body=ITEExpression(condition=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='<', e2=SelfEvaluatingExpression(id=1)), ifbody=SelfEvaluatingExpression(id=0), elsebody=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='+', e2=CallExpression(procname=VariableExpression(name='x'), params=[BinaryOperatorExpression(e1=VariableExpression(name='y'), op='-', e2=SelfEvaluatingExpression(id=1))])))))], body=BinaryOperatorExpression(e1=CallExpression(procname=VariableExpression(name='x'), params=[SelfEvaluatingExpression(id=2)]), op='+', e2=VariableExpression(name='x')))
# End of LocalExpression(localvars=[('x', SelfEvaluatingExpression(id=1))], body=SequenceExpression(seq=[LocalExpression(localvars=[('x', LambdaExpression(params=['y'], body=ITEExpression(condition=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='<', e2=SelfEvaluatingExpression(id=1)), ifbody=SelfEvaluatingExpression(id=0), elsebody=BinaryOperatorExpression(e1=VariableExpression(name='y'), op='+', e2=CallExpression(procname=VariableExpression(name='x'), params=[BinaryOperatorExpression(e1=VariableExpression(name='y'), op='-', e2=SelfEvaluatingExpression(id=1))])))))], body=BinaryOperatorExpression(e1=CallExpression(procname=VariableExpression(name='x'), params=[SelfEvaluatingExpression(id=2)]), op='+', e2=VariableExpression(name='x')))]))
getbasic
